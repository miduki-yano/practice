/*
//----「let」「const」「var」の使い分け--------------------------------------------//
let name1 = 'いちご';
const name2 = 'バナナ';

name1 = 'もも';//代入して上書き可能
console.log(name1);

name2 = 'りんご';//constで定義されたら定数となり、再代入はできない
console.log(name2);

//--------------------------------------------------------------------------------//
*/
/*
//--------------------------------------------------------------------------------//

let name3 = 'いちご';
let name4 = 'もも';

let name3 = name4;//letで定義された変数は、再定義できない※constも同様
let name4 = 'みかん';//これもできない

//--------------------------------------------------------------------------------//
*/
/*
//--------------------------------------------------------------------------------//

const myobj ={
    name:'いちご',
    price:300
}

myobj.name='ライチ';//constで宣言しても、オブジェクトのプロパティと配列の要素は変更可能
console.log(myobj.name);//「ライチ」が表示される

//--------------------------------------------------------------------------------//
*/
/*
//--------------------------------------------------------------------------------//

let name5 = 'トマト';//グローバル変数
var name7 = 'たまご';//グローバル変数
name8 = '寿司';//グローバル変数

if(true){
    var name6 = 'きゅうり';//ブロックの中で定義してもブロックスコープがない
    name5 = 'なす';//letなので再代入OK
    name8 = 'タコス';//グローバル変数なので再代入OK
}

console.log(name5);//letの変数の場合、ブロックスコープだが、
//グローバル変数として宣言しているため、ブロック({})外でも呼び出せる
console.log(name6);//varはブロックスコープではないため、ブロック内で定義したvar変数をここで呼び出せる
console.log(name7);//どこからでもアクセスできるグローバル変数を呼び出した
console.log(name8);//ブロック内で再代入したグローバル変数を呼び出した


//--------------------------------------------------------------------------------//
*/
/*
//-----以降は「ホイスティング」について--------------------------------------------//

f();//関数に対するホイスティングのため、関数より前に実行文を書いてもエラーにならない

function f(){
    console.log('hoistingtest');
}

//--------------------------------------------------------------------------------//
*/
/*
//--------------------------------------------------------------------------------//

//事前に変数ⅹのメモリ確保
console.log(x);//この時点では、ⅹに値は代入されていない(メモリが確保されているが、中身の値は空)
//エラーではなく、undefined(未定義)が代入され、表示される

var x = 1;//※ここでは１は表示されない、変数に値を代入しただけ

console.log(x);//このコードを追加して初めて、１が表示される

//--------------------------------------------------------------------------------//
*/
/*
//--------------------------------------------------------------------------------//

//事前に変数ⅹのメモリ確保
console.log(x);

let x = 5;//varと違って、自動でundefinedが代入されないため、エラーとなる
//const x = 6; これも同様

//コンソール：Uncaught ReferenceError: Cannot access 'x' before initialization
//初期化前にｘにアクセスできません。→変数ｘには何も入っていません！

//--------------------------------------------------------------------------------//
*/
/*
//--------------------------------------------------------------------------------//

let x = 10;//グローバルスコープで宣言した変数ｘ

{
    //この辺に、下の「let x = 0」ホイスティングにより、中身がない変数ｘが定義される
    console.log(x);
    //上にグローバル変数があるものの、ブロック内({}内)のトップの中身がない変数ｘがここで使われる
    //変数ｘには何も入っていないというエラーになる

    let x = 0;//後からローカルスコープで(ブロック内で)宣言した変数ｘ

}

//※{}内のletによる変数の宣言を、グローバル変数の「let X」と同じ変数名ではなくすれば、
//グローバル変数を使うことができる

//--------------------------------------------------------------------------------//
*/
